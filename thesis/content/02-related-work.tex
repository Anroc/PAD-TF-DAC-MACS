\section{Related Work}
\todo{
	* **Related work**\\
	* Of paper did something similar to this\\
	* Comparison paper\\
	* Not \ac{ABE} paper
}

\todo{
	Cite \cite{lee2013survey} and similar overview paper
}

% \subsection{Attribute-Based Encryption}
% Attribute Based Encryption (\ac{ABE}), first introduced by Sahai and Waters \cite{sahai2005fuzzy}, is a cryptographic encryption scheme which uses attributes of a user as keys for encryption. This enables the data owner to craft a ciphertext over chosen attributes that can only be decrypted by any entity that holds a super set of matching attributes. Further, it is possible to embed a complex access structure (e.g. access trees) inside the cipher text, where each node contains \textit{\ac{AND}} or \textit{\ac{OR}} threshold gates. This approach is known as Ciphertext-Policy Attribute-Based Encryption (\ac{CP-ABE}) \cite{bethencourt2007ciphertext}. 
% It is also possible to do it the other way around: Associate the user's key with an access policy, formally known as Key-Policy Attribute Based Encryption (\ac{KP-ABE}).\cite{goyal2006attribute}. 
% %Now the encryptor needs only to encrypt a given plain text with the public key of specific attributes so that only users who hold the right keys are able to decrypt the cipher text.

% Both approaches are limited to one attribute authority (\ac{AA}). So only one trusted entity is in charge of issuing attributes and their matching key pairs. However, in the real world we would like to distribute the issuing of attributes over different authorities. A new scheme is needed where different attribute authorities cooperate and communicate across different domains.  

% % The basic idea is, as proposed in \cite{chase2007multi}, to construct for each users a polynomial of degree $d-1$, where $d$ donates the number of attributes in our system. 

% Multi-Authority Attribute Based Encryption (\ac{MA-ABE}), first proposed by Chase 2007 \cite{chase2007multi}, allows multiple attribute authorities to maintain different attribute domains. To ensure collusion resistance between users, a trusted  Central Authority (\ac{CA}) was introduced to assign each user an unique identifier (\ac{UID}) and making the decryption process depending on this \ac{UID}. Its disadvantage is the \ac{CA}'s global decryption power and therefore the necessity to remain trusted. 
% %To prevent collusion between user in a multi authority setting, the challenge for each user needs to be individual. But it still needs to be ensured that the encryption of a message is independent of any user specific identifier, since the encryption progress should sourly depend on the attribute set known to the system.
% %To mitigate this problem a global identifier (\ac{GID} or \ac{UID}) per users was introduced that is shown to each attribute authority (\ac{AA}) to receive the corresponding private key for the users attributes. 
% %The central authority (\ac{CA}) now has to make sure that the user dependent challenge results in a global decryption key to decrypt the message.
% %In fact the \ac{CA} has to be trusted since it computes the users private keys in such a way that on decryption it reveals the global decryption key. 
% Chase \textit{et al.} addressed this issue in \cite{chase2009improving} by distributing the global secret  master key generation over the \ac{AA}s. However, since the global master secret is computed on system initialization, no further \ac{AA}s can be added afterwards without rebooting the system. Also the scheme did not support attribute revocation which rendered it practical not applicable.
% % Each authority uses this seed in combination with a pseudo random function to deterministically create the users private key. Since the \ac{CA} possesses the same seed, same pseudo random function and issues the users \ac{GID}, it can also compute the same private key as issued by the corresponding \ac{AA}. So it can ensure that on decryption the keys add up to reveal the global decryption key. This scheme has a major issue: The \ac{CA} has global decryption power. 

% % Chase notices this problem as well and tried to mitigate it by decentrializing the seed generation \cite{chase2009improving}.  First user attributes could not easly be revoked\footnote{Chase proposed to assign each user a range of \ac{GID}s, so that a user can migrate to the next \ac{GID} on revocation. Since the \ac{GID} range is finite, this solution does not scale.}. Second \ac{AA}'s cant be added on runtime without reissuing each user his keys. And last, the attribute universe is finite (no large-universe). Further we noticed that if a failure of one \ac{AA} renders the system unresponsible, since a cyphertext includes attributes from each authority. 

% Data Access Control for Multi-Authority Cloud Storage Systems (\ac{DAC-MACS}) \cite{yang2013dac} is a scheme that tackles both of this issues. Each authority receives its own ciphertext that depends solely on the attributes issued in this domain. While Chase managed to maintain the "one-plaintext-one-ciphertext" ratio, \ac{DAC-MACS} needs to create $k$ ciphertexts: One per \ac{AA}.\footnote{If the ciphertext does not require any attributes of an specific authority it does not have to create a ciphertext for this domain.} It does not require any coordination between authorities which enables to add new \ac{AA}s at runtime without recreating the user keys. This scheme also includes features for efficient revocation while it claims to maintain forward and backward secrecy. 

% \ac{DAC-MACS} is not collusion resistance on attribute revocation under the active attack model. The scheme \ac{NEDAC-MACS} (New Extended \ac{DAC-MACS}) shows and solves this vulnerability \cite{wu2017security}. Recent studies introduce a more efficient, scalable and secure approaches such as \ac{MAACS} \cite{li2016secure} and \ac{TF-DAC-MACS} (Two-Factor \ac{DAC-MACS})\cite{li2017two}. The \ac{DAC-MACS} family is further known for the proxy decryption technique, first introduced by \cite{li2013matrix}, where a honest-but-curious server helps the user on decryption.

% Priscilla and Nagarajan 2018 \cite{nagarajan2018overview} conducted an analysis of the \ac{DAC-MACS} family. In addition to that work, this thesis will focus on alternative approaches to improve scalability of secure cloud storage systems and analyze the field of \ac{ABE} and \ac{MA-ABE} more deeply.