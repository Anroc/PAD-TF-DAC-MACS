\section{Introduction}
\label{sec:introduction}
\todo{
    * **Introduction**\\
    * Ruff problem describtion\\
    * How \ac{ABE} can solve this\\
    * How \ac{ABE} works\\
    * Short history summary of \ac{ABE}\\
    * What is expected of this work\\
    * What are the targets
}
\lettrine[nindent=0em,lines=3]{I}n public-key cryptography each user is identified by his unique public and private key pair. Peer-to-peer communication works well with this scheme, but as soon as an encrypted content needs to be accessed by multiple participants, the data owner has to encrypt the content for each user explicitly. This results in many encrypted versions of the same  file, each secured by a different public key. Such scheme does not scale in the secure cloud storage domain. Here often data holders want to share the same content with many other users at the same time.

We reach the point where the classical public-key end-to-end encryption scheme does not scale anymore. We would like to employ an encryption scheme which has a constant number of access keys regardless of the number of participants.
\todo{extend}

\subsection{Secure cloud storage system}
In the past 20 year we witnessed a shift of resource consumption on the user side to outsourcing more and more resources into the cloud. Naturally, users moved their files and pictures into cloud storage systems. This helped companies to maintain an ecosystem around the user helping him to synchronize his files and photos to different devices.  

With increasing transparency raised also the concern that it was not clear anymore who could access the private files especially when they are transmitted and stored on oversee servers. Bdrive, a secure cloud storage system, promises to not export files and data to other countries. It splits up files in smaller chunks that are saved separately on different cloud storage provider (\ac{CSP}). To ensure end-to-end encryption a Bdrive client encrypts locally each of its chunks with a one-time symmetric key that is then encrypted under its own public key. This encrypted key is called a file key and it is uploaded to the Bdrive server where it is stored securely (see figure \ref{fig:filekey}).

\subsection{Rekeying}
\subsection{Background}
\begin{figure*}[!ht]
\centering
    \includegraphics[width=0.8\linewidth]{img/bdrive1.png}\par 
    \caption{Client uploads an encrypted file to the \ac{CSP}s and the file key and public key to Bdrive.}
    \label{fig:filekey}
\end{figure*}
\begin{figure*}[!ht]
\centering
    \includegraphics[width=0.8\linewidth]{img/bdrive2.png}\par
    \caption{Client A grants Client B access to the uploaded file by re-keying the file key}
    \label{fig:rekey}
\end{figure*}
Since each device of the same user has a different private-public key pair, the device is in charge of making the file keys accessible for a new device. This will be done by downloading each file key for the respective file, receiving the public key of the new device, decrypting the file key with its own private key, encrypting it again with the public key of the new device and finally, uploading the new file key to the Bdrive server. This process will be called re-keying (see figure \ref{fig:rekey}). In the later sections we will referee to clients as devices. 

% File upload and file key creation
In Bdrive each device of a user generates a new \ac{RSA} key pair on registaion. The fingerprint (hash) of the public key identifies the device uniquly. To save a file in the cloud the device fist encrypes the file symmetrically with the so called "filekey". The filekey equals the hash of the plain file content and so ensures tamperproofness and integrity on decryption. End-to-end encryption implies that the server should never be able to decrypt the file by itself. To enforce this the device encrypts the filekey asymmetrically with its own public key before uploading the filekey to the Bdrive server where it is stored securly. In Bdrive, the encrypted file chunks are uploaded to the different cloud storage provider (\ac{CSP}). 

% Access file
If the user wants to access a file locally, the devices requests the encrypted filekey from the server and downloads the file chunks from the \ac{CSP}s. Locally, it decrypts the filekey with his private key and finally deciphers the assembled file with the decrypted filekey. 

% Process for multibe devices
So far we took a look on how the encryption process is handled for a single device. However, this process turns out to be much more computationally complex in a multiple device setting.  If a user registers more then one device the existing data needs to be synchronized to the new device. The server notifies the existing device for the newly registered one and the public key of the new device is downloaded. Now the existing device needs to download each filekey for each file of the user and decrypts it. The synchronization is finished by encrypting the filekeys with the new devices public key and uploaded again to the server. The new device can now start to download and decrypt the file chunks as described previously.

Usually in cloud storage systems we also have the concept of groups. They are a collection of clients which share data between them. For that they form a so called \textit{share}. To somehow express the overhead of joining or leaving a share we will use the following notation. $f$ and $n$ donate the creation of the number of filekeys and is the number of devices in a share respectively.

% Adventages
If a new devices joins a share in Bdrive we need to make the existing file keys available to the new devices which results in $O(f)$ additional encryptions, messages and keys. However, a big advantage of this scheme is that forward secrecy\footnote{Forward Secrecy: The left entity will have no knowledge about future shared content.} will not produce additional overhead. We simply remove all the filekeys belonging to the left device and do not further encrypt new uploaded files for this device anymore. The backward secrecy constraint, while being an imported security feature, will explicitly be broken by clients. This is due a data owner invites a new member into a group he wishes that the new member receives all previous uploaded content. Bdrive is ensuring this by explicitly reencrypting all file keys for the new device. 

\subsection{Problem description}
% Bdrive rekeying
% Motivation and Problem description

% Disadventages in shares
Notice, that this approach does not scalable for a large number of devices. Lets look at the use case of creating a new share. Each device of invited to a share needs to have an own version of the file key, encrypted with the devices public key, issued. This process scales with $O(n * f)$ keys. 
%Were $n$ donates the number of devices involved in the sharing and $f$ the number of file versions in the share.\footnote{Each file consist of many file versions. Each file version needs an own file key since for each content change a new file is updated.}
Further, we need to send the same number of messages containing the encrypted file key and we need to encrypt each filekey $n$ times which also results in $O(n * f)$ encryptions in total. 

To informally describe this problem lets assume we have an CEO of a 50 employee company who wants to create a company wide share. Each of the employee has at least two devices (say one web view client and a desktop client). To upload the latest presentation the client of the CEO know has to create $50 * 2 = 100$ filekeys to upload, $100$ messages to distribute $100$ encryptions to make. Even worst for each new presentation upload another $100$ filekeys need to be maintained. In a large scale company this overhead becomes unmaintainable.

\subsection{Attribute-Based encryption}
\textit{Attribute-Based Encryption} (\ac{ABE}) defines users over attributes and attribute keys rather then its individual public key. Since users are not unique among their attribute set it is possible to reduce the number of needed keys of a share to the number of attributes necessary to describe the group completely. 

Attributes are issued by a \textit{Attribute Authority} (\ac{AA}). This authority has global decryption power in the domain it administers. For that reason we need to split up the attributes into different domains, each managed by an own AA. In the use case of cloud storage systems for business it makes sense to setup an own AA for each company.

With ABE we also get the advantage of defining access policies for cipher texts. This policies consist of boolean formulas with attribute values as inputs. Only if a user satisfies the given policy he is able to decipher the cipher text.

In our use case inter company sharing becomes tricky. Now different AAs need to cooperate to create cipher text policies containing attributes of the whole ecosystem.  

ABE scales with the number of attributes contained in a cipher text. Usually some could assume that the set of attributes is smaller than the total number of devices in the ecosystem. Which makes ABE scale better then the current rekeying scheme in Bdrive. 

\subsection{Contribution}
The target of this work is to find a more scalable solution to the currently enrolled re-keying scheme in the domain of secure cloud storage systems. Different schemes need to be evaluated against each other to find most scalable solution and with respect to the requirements of section section \ref{sec:requirements}. Further, intra-company management (each company administrates only its own domain) and inter-company file sharing (it is possible to share files across companies) should still be possible. The selected scheme should be practically applicable in the real world.