\section{Multi-authority attribute based encryption}
In the following the different sub topics of Multi-Authority Attribute-Based Encryption (\ac{MA-ABE}) will be described, analyzed given all the requirements and finally evaluated based on their performance and scalability. 

\subsection{Introduction into Multi-Authority Attribute-based Encryption}
Chase 2007 \cite{chase2007multi} was the first known to introduce the first \ac{MA-ABE} schemes. In her paper she describes the process on how to derive a multi-authority attribute-based encryption scheme from the single authority schemes. While chase's scheme also used bilinear maps its main security is based on interpolation and the fact that no under defined linear equation system could definitely be solved\footnote{\ac{LSSS} matrix are based on the same assumption.}.  

To ensure collusion resistance each user is given blinded attribute private keys so that when used on decryption the plain text is still blinded with the user specific identifier. Using pairings this identifier can be substituted and the plaintext gets revealed. 

Chases scheme had two major disadvantages, which were not addressed in the initial scheme. First the \ac{CA} had global decryption power. That was due to the fact that it needed to issue each \ac{AA} a specific seed so that on using this seed in a pseudo random generator the \ac{CA} knew what random value would be calculated. This information is used to precompute the users secret key so that when later combined with the secret attribute keys, it resolves in the correct plain text. This was important since the CA was defined as the trusted authority, the AA was not. So the cipher text need this extra security layer.  

Chase improved her scheme 2009 in \cite{chase2009improving}. Now all \ac{AA}s will do a n-party key exchange to distribute the secret seeds with each other. This results in the fact that each no AA know the whole master secret, but only its required secret seed. Agreeing on a well known value the \ac{CA} was no longer required and as long $N-2$ \ac{AA}s are not colluding with each other the secret remained secure. 

The other disadvantage, that was still present in the updated scheme, was that no new \ac{AA} could be added after system initialization since it would trigger a new system bootstrap and distribution of the master secret. 

The lack of adding new attributes and the missing revocation scheme made chases scheme impractical for further evaluations but gives a good introduction the challenges of the \ac{MA-ABE} schemes.

\subsection{Hierarchical \ac{ABE}}
\label{sec:HABE}

\begin{figure*}[!ht]
\centering
    \includegraphics[width=0.7\linewidth]{img/HABE.png}
    \caption{Structure of hierarchical attribute-based encryption systems}
    \label{fig:habe}
\end{figure*}

Hierarchical Attribute-Based encryption (\ac{HABE}) takes the key delegation one step further. It is sourly designed around the idea that if a private key exist that have a certain access power, it is possible for the key holder to delegate a subset of his access power to a new instance. By nature follows a hierarchical structure where each user could administrate an own subdomain. Many use cases for cloud computing as well as cloud storage system emerged. \cite{Wang:2010:HAE:1866307.1866414}. While some works also take revocation into design a curl requirement is still missing. The domain master has always global decryption power. 

As displayed in figure \ref{fig:habe}, which is based on the approach in \cite{wang2011hierarchical}, the root master summarized the global decryption power of the system and can set up new domain masters (attribute authorities). They on the other hand can delegate a subset of decryption power to a sub domain master. Each domain master can administer users and attributes.

\cite{Wang:2010:HAE:1866307.1866414} formalized this approach using \ac{CP-ABE}, which was later extended in \cite{wang2011hierarchical}. While implementing a revocation scheme, they depend on an access policy present in disjunctive normal form (\ac{DNF}). Any Boolean formula can be transferred into DNF but sometimes this might enforce negation. \cite{wang2011hierarchical} does not provide any negation mechanism so this scheme restricts us to DNF formulas that will not use negation.  

\subsection{Decentralized attribute-based encryption}
\label{sec:DABE}
In contrast to HABE stands \textit{decentralized attribute based encryption} (\ac{DABE}) which is designed arround the idea of having a peer network work of authorities and user. No entity has a global view onto the system and is in charge of issuing authority keys. This ecosystem is self sustaining in the form that each entity can become an \ac{AA} if needed and start issuing new attributes to users. 

However, some form of centralization must still be present. The global parameters, for example , need to be known to each new entity and each user still need to get a unique global identifier assigned to prevent collusion. Also attributes need to be synchronized since the set of attribute identifier need to be non intersecting across different domains. All this information could be published by a public bulletin board and the first DABE scheme was designed by \cite{lewko2011decentralizing}. 

Revocation in such system remains an open issue. Since no central authority manages all users, no authority can be in charge of revoking them. An authority could revoke its issued attributes but only in an indirect fashion since decentralized systems are build around the idea that nodes can go offline at any time. If an authority would go offline as soon at it received the revocation request the revocation procedure would never trigger. 

Cui and Deng showed in \cite{cui2016revocable} that such a system could exist. Each key and ciphertext got a liveness assigned which make them valid for a certain time period. After the time period expired all keys need to be reissued by each \ac{AA}. Indirect revocation happens by simply excluding the user from reissuing certain attribute keys. This system is implemented in the comparison in \ref{sec:ma-comparison}.

The question remains if such a system would be practically applicable since each cipher text needs to be reuploaded in each time period. Further, direct revocation DABE still remains an open issue.

\subsection{Efficient Data Access Control for Multi-Authority Cloud Storage}
The most explored field in \ac{MA-ABE} is the Efficient Data Access Control for Multi-Authortity Cloud Storage (\ac{DAC-MACS}) family \cite{yang2013dac}). First introduced by Yang \textit{et. al.} 2013 it describes an efficient, revocable \ac{MA-ABE} scheme based on \ac{CP-ABE} which uses proxy encryption on decryption and reencryption to make the scheme more efficient. Further, this scheme features a large attribute universe, adding \ac{AA}s on the running system and deescalates the global decryption power of the \ac{CA}. In sort \ac{DAC-MACS} satisfy all the non-optional requirements.

In contrast to Chases scheme, DACMACS eliminates the need for the global decryption power of the \ac{CA} by issuing $k$ ciphertexts: One per \ac{AA}. \footnote{If the ciphertext does not require any attributes of an specific authority it does not have to create a ciphertext for this domain.} It does not require any coordination between authorities which enables to add new \ac{AA}s at runtime without recreating the user keys. This scheme also includes features for efficient revocation while it claims to maintain forward and backward secrecy.

\ac{DAC-MACS} is not collusion resistance on attribute revocation under the active attack model. The scheme \ac{NEDAC-MACS} (New Extended \ac{DAC-MACS}) shows and solves this vulnerability \cite{wu2017security}. Recent studies introduce a more efficient, scalable and secure approaches such as \ac{MAACS} \cite{li2016secure} and \ac{TF-DAC-MACS} (Two-Factor \ac{DAC-MACS})\cite{li2017two}. 

Another notable technique recently used by \cite{yang2013dac}, \cite{wu2017security}, \cite{li2017two} and \cite{wang2011hierarchical} is \textit{proxy de-/reencryption}. It is motivated by the fact that mobile devices often don't have much computing resources so the server helps the clients on decryption. The main idea is that the server does the preprocessing of the encrypted text given parameters by the user. Impotent to note is that the server will have no knowledge about the plain text since the preprocessed cipher text is still encrypted with the users public key. 

All the \ac{DAC-MACS} schemes are structured in roughly the same way. They usually describe six different entities:

\begin{enumerate}
	\item \textbf{Certificate/Central Authority (\ac{CA})} The purpose of the \ac{CA} is to issue user their global identifier (\ac{GID}). Further, it bootstraps the different \ac{AA}s. The \ac{CA} remains trusted but do not have any decryption power in the system. 
	\item \textbf{Attribute Authority (\ac{AA})} An attribute authority administers their domain. Issues attributes and their respective private key to the user. They only accept a user if his \ac{GID} is signed by the \ac{CA}. 
	On revocation they will need to update the users secret keys as well as the ciphertext encrypted with the revoked attribute key. \ac{AA}s are assumed to be trusted but can be compromised by an adversary.
	\item \textbf{Server} The purpose of the server is to help the user with proxy re- and decryption. If an \ac{AA} broadcasts a revocation of an attribute, the server downloads all related ciphertexts from the \ac{CSP} to update them with the new attribute. 
	Further, the user may give the server his attribute private keys so that the server can precompute the ciphertext. The thread model for the server is honest-but-curious. Please note, that the \ac{CA} and the server are two separated entities that do not cooperate.
	\item \textbf{Data owner} The data owner are users who want to encrypt content with a specific access policy. To do so they use the public available public attribute keys pinned on the bulliton board of the respective \ac{AA}. Data owner do not have to know anything about the receiving user or user groups in the system. After encryption they update the encrypted content to the \ac{CSP}.
	\item \textbf{Cloud storage provider (\ac{CSP})} The cloud storage provider are assumed to be untrusted but they still follow the protocol. That’s why they only receive encrypted data. They only purpose is to store the ciphertext and make them puritanically available. No authentication checks are needed.
	\item \textbf{Users} Users exist in two groups: Revoked and non-revoked. Non-revoked user try to collude with each other to get a higher level of decryption power. They download the files of the \ac{CSP} and try to decrypt them. Only if they attribute set matches the policy of the ciphertext they will be able to decrypt the file. 
	Revoked users, on the other hand, try to still decipher ciphertext. In some cases they try to collude with non-revoked user to intercept the key update key to restore their decryption rights. 
	User are in general untrusted.
\end{enumerate} 

For the comparison we will use the charm implementation of DAC-MACS \cite{yang2013dac}.

\ac{TF-DAC-MACS} counts as the most advanced \ac{DAC-MACS} scheme providing non global decryption power, secure revocation channels and both backward and forward secrecy. In addition \ac{TF-DAC-MACS} introduces the two factor authentication. Data owner can issue and revoke \textit{authentication keys} to and from other users. This adds an additional layer of security. In total \ac{TF-DAC-MACS} archives still better performance then the other \ac{DAC-MACS} schemes providing constant decryption and encryption overhead. 
To compare the TF-DAC-MACS with the others we will implement TF-DAC-MACS from scratch. 

\subsection{Comparison}
\label{sec:ma-comparison}
\begin{table*}[!ht]
\centering
\begin{tabular}{l 					| l 									| l 									| l 					| l}
									& \thead{LTXWC 16\\(TF-DAC-MACS)\cite{li2017two}} & \thead{YJ 14\\(DAC-MACS)\cite{yang2013dac}} & \thead{LW 14\\ (HABE)\cite{wang2011hierarchical}}	& \thead{CD 16\\(DABE)}\cite{cui2016revocable} \\
\hline
\thead{Scheme}						& \makecell{CP (DAC-MACS \\ without proxy \\ 
									  decryption, 
									  with \\ two-factor \\ authentication)} & \makecell{CP (DAC-MACS \\ 
									  										  with proxy \\ decryption)} 			& CP (Hierarchical) 		& CP (Decentralized)		\\ 
\hline
\thead{Revocation}					& Direct 								& Direct 								& Direct 				& Indirect					\\
\hline
\thead{Security scheme}				& Bilinear maps 						& Bilinear maps 						& Bilinear maps 		& Bilinear maps 			\\
\hline
\thead{Expression of \\ access policy} & n-of-n threshold					& LSSS		 							& DNF 					& LSSS matrix 				\\ 
\end{tabular}
\caption{Scheme description. }
\label{tab:comparison_ma_abe_overview}
\end{table*}
\begin{table*}[!ht]
\centering
\begin{tabular}{l 	| l										| l 									| l 					| l}
					& \thead{LTXWC 16\\(TF-DAC-MACS)\cite{li2017two}} & \thead{YJ 14\\(DAC-MACS)\cite{yang2013dac}} & \thead{LW 14\\ (HABE)\cite{wang2011hierarchical}}	& \thead{CD 16\\(DABE)}\cite{cui2016revocable} \\
\req{C1}			& Yes									& No 									& Yes 					& Yes 						\\
\req{C2}			& Yes									& Yes 									& Yes 					& Yes 						\\ 
\req{C3}			& Yes									& Yes 									& No 					& Yes 						\\ 
\req{C4}			& Yes									& Yes 									& No 					& Yes 						\\ 
\req{C5}			& Yes									& Yes 									& Yes 					& Yes 						\\ 
\req{C6}			& Yes 									& Yes 									& Yes					& Yes						\\
\req{C7}			& Yes									& Yes 									& No 					& Yes 						\\
\req{C8}			& Yes									& Yes									& Yes					& Yes-						\\
\req{O1}			& No 									& No 									& No 					& No 						\\
\req{O2}			& No 									& Yes									& Yes					& Yes						\\
\end{tabular}
\caption{Requirements comparison of the implemented schemes}
\label{tab:ma_abe_comparisons}
\end{table*}


\begin{figure*}[!ht]
\centering
    \includegraphics[width=1\linewidth]{img/maabe_comparisons.png}
    \caption{Performance and scalability comparison}
    \label{fig:maabe_comparison}
\end{figure*}

To compare the sub topics of \ac{MA-ABE} we need to extend the charm framework with an implementation of \ac{DABE}, \ac{HABE} and \ac{TF-DAC-MACS}. \ac{DAC-MACS} on the other hand existed in the framework already. 

In general we extracted five steps that each \ac{MA-ABE} scheme need to provide in some form. 
\begin{enumerate}
	\item \textbf{Setup:} The global setup phase where public parameter are determined.
	\item \textbf{Authority Setup:} \ac{AA}s can register itself to the central authority (if any) and compute their secret keys. Usally, the attribute secret keys are generated. 
	\item \textbf{Register User:} In the \ac{DAC-MACS} schemes user receive public and private key components. Other schemes just assign the user a \ac{GID} and signs them.
	\item \textbf{Key generation:} Attributes are assigned to user and the respective secret keys are generated.
	\item \textbf{Encrypt:} The cipher text is encrypted by the data owner under an access policy.
	\item \textbf{Decrypt:} The user (with the help of the server) decrypts the cipher text and recovers the secret message. 
\end{enumerate}

This steps are shown and compared in \ref{fig:maabe_comparison}. We can argue that \ac{DAC-MACS} performed the worst, then \ac{DABE}, then \ac{TF-DAC-MACS} and the best performance has \ac{HABE}. \todo{extend analysis} 

However, for piratical usage especially the encryption and decryption performance is important. There only \ac{TF-DAC-MACS} has an constant overhead while all other schemes are linear. If we further have a look at the table of requirements \ref{tab:ma_abe_comparisons}, we see that only two schemes satisfy all of the requirements: \ac{TF-DAC-MACS} and \ac{DABE}. \ac{DABE} profits also from the fact that it has a more fine grant access control then \ac{TF-DAC-MACS}. However, its revocation scheme is the disadvantage that leave us with \ac{TF-DAC-MACS} as our final candidate. As mentioned in section \ref{sec:DABE} the implemented scheme uses indict time-based revocation, which forces data owner to periodically re-encrypt and re-upload their content. This is in a cloud storage system not really applicable. 

The comparison of \ac{TF-DAC-MACS} with other schemes of the \ac{DAC-MACS} family was left out in this work, since it was already done in the \ac{TF-DAC-MACS} paper \cite{li2017two}. Here some could easly see that \ac{TF-DAC-MACS} is currently the most performant scheme in the \ac{DAC-MACS} family.  