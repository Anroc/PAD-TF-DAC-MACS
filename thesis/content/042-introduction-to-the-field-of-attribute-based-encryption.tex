\section{An Introduction To The Field Of Attribute-Based Encryption}
A key requirement in security of distributed systems is authenticity. It describes the principle of associating individuals with their digital representation. A so called \textit{public key infrastructure} (\ac{PKI}) uses certificates which validate the public key bound to an identity.

\textit{Identity-Based Encryption} (\ac{IBE}) tries to circumvent this standard by binding identities to unique strings already associated with this identity, such as an email address. If encrypted directly with this identifier, no certificate validation check needs to be done to validate the identity of the recipient. 

\subsection{Identity-Based Encryption}
The idea of using universal identifier instead of public keys to identify individuals goes back until 1984. Shamir proposed the first identity-based encryption schem 	te{shamir1984identity} which uses a central authority to create for each newly registered user a unique universal identifier (e.g. the email address). This identifier can be used for encryption in the same way as public keys were used. However, the difference to \ac{RSA} is that, since the universal identity is the public key, the use of a certificate to bind the public key to an identity becomes nugatory. 
Since the sender has to know the email address of the recipient anyways he can derivative public key component from it, encrypt the email with this key and can be sure that only the identity owning this email can decipher the content. 

Since this scheme could neither be shown to be practical applicable, nor to proven secure, it was not until 2001 when Boneh and Franklin proposed in \cite{boneh2001identity} a new approach to identity-based encryption. The use of the \textit{Weil pairing} revolutionized the field of identity-based encryption.\footnote{Curious reader can readup on the weil pairing here \cite{Miller2004} \cite{galbraith2008pairings} or here \url{https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627}}

\subsection{Bilinear Mappings}
\label{sec:bilinearmappings}
Bilinear mappings are a tool for \textit{cryptographic pairings} and define the relationship between two cyclic groups of the same order into a third one. A cyclic group $G$ is defined by an generator $g$ of that form that each $g^n \in G$ with $n \in \mathbb{Z}$ completely describes each element in the group $G$.

A bilinear map function $e$, also called \textit{pairing} is now defined as the mapping between two groups of the same order $G_1$ and $G_2$ into $G_t$:

\begin{gather*}
 e : G_1 \times G_2 \rightarrow G_t \\
\text{ such that for all } g_1 \in G_1, g_2 \in G_2, a, b \in \mathbb{Z} \\
e(g_1^a, g_2^b) = e(g_1, g_2)^{ab} 
\end{gather*}

If $G_1$ and $G_2$ describe the same group the mapping is called symmetric. In fact the \textit{decisional bilinear Diffie-Hellman problem} becomes easily computable using bilinear mappings \cite{bethencourt2015intro}.

This construct of pairings is used by many schemes to either distribute a secret or computing the secret without revealing it.

\subsection{Attribute-Based Encryption}
\textit{Attribute-Based Encryption} (\ac{ABE}) is ancestor of IBE. Instead assigning each user a unique identifier, the work of Sahai and Waters \cite{sahai2005fuzzy} describes the approach of assigning each user a descriptive set of attributes. A deeper dig into this topic reveales the well known setup from \ac{IBE}: a central \textit{attribute authority} (\ac{AA}) manages attribute private and public keys, generates user specific attribute secret keys and serves as a central public-key directory. 

One advantage is that the \ac{AA} doesn't have to be online all the time. Once the attributes are issued and distributed the data owner, without any further interactions with the \ac{AA}, can use those to share content to authorized members. Further, no authorization checks are needed. This follows due to the fact that if the entity was authorized to download the content, it will certainly also be able to decrypt it. 

As already known, content is encrypted using a set of attribute public keys, rather then public keys of individuals. This implies that the data owner encrypting the file does not really know which individual deciphers the ciphertext. Using boolean formula and the given attribute universe, the data owner creates an access policy securing his ciphertext. Any entity owning a certain set of attributes that fulfill this policy is allowed to access the data. This feature comes in handy in specific domains such as the medical domain. For example any set of doctors satisfying certain attribute are able to access the medial record. The patient, as the data owner, does not care about the real identities of the doctors only if they satisfy a specific qualification goal. The same is applicable on file-sharing in the business domain. Here users often share content to roles or group of members and if an employee gets promoted he automatically gets access to the content addressed to his job level. 

Further, user management systems always need a procedure to revoke users and their attributes. 
In general two steps need to be made to revoke an attribute from a user. All users, except the revoked user, need to receive a new secret key for this attribute and in addition, each ciphertext encrypted under this revoked attribute need to be updated to ensure forward secrecy and decryptability for the new attribute secret keys. 

In summary ABE provides a big advance for the rekeying problem: Since new members joining a group just receive the respective attribute keys no group key needs to be distributed. Users are automatically member of a group if they satisfy the access policy. With \ac{ABE} it is possible to go beyond the natural limitation of Secure Group Communication schemes which had a lower bound of one new key per newly joined member.  

\todo{Answer question here? Is Bdrive secure against AA?}

\subsection{Collusion Resistance}
\textit{Collusion resistance} in the main requirement of each ABE scheme. Formally it describes that no two entities are able to combine their attributes to achieve a higher level of decryption power. To clarify the importance of collusion resistance a very basic attribute based encryption scheme is constructed. Assume a distributed crypto-system based on \ac{RSA}. The role of the \ac{AA} is to bind attributes to \ac{RSA} public-private key pairs. The attribute "student" gets bound to $K_{PR(s)}$ for the private key and $K_{PU(s)}$ for the public key. Attribute "works at TU Berlin" gets bound to the key $K_{PR(tu)}$ and $K_{PU(tu)}$ respectively. Now, the very first ABE scheme is created. The AA can pin the public keys of each attributes to its public billboard so that every entity in the system can use the public attribute keys for encryption. Each user who is currently a student receives a copy of the private key $K_{PR(s)}$ and each user who is currently working at TU Berlin receives a copy of $K_{PR(tu)}$. 

A user, lets call her for historical reason Alice, wants to share content with all students that are also working at TU Berlin. With our basic scheme Alice is able to use \textit{layered encryption}\footnote{Layered encryption: encrypting a plain text with multiple keys, forcing the decryptor to own all relevant keys} to create an \textit{AND}-policy for her cipher text. She encrypts the plain text $p$ with both public attribute keys $c = K_{PU(s)}(K_{PU(tu)}(p))$ and publishes the ciphertext $c$ to a public CSP so that everyone can download it. Students that are working at TU Berlin owning both private keys can decipher the ciphertext by applying both private keys in reverse order $K_{PR(tu)}(K_{PR(s)}(c)$.

The attentive reader will have notice a crucial security leak in this scheme. This \ac{ABE} scheme is not collusion resistant. On paper collusion resistance it is defined as the impossibility of any two attribute holder to combine their attributes to achieve a higher level of decryption power. Lets assume that Bob is a student and Eve is working at \ac{TU}-Berlin. Both users received their respective private keys. Now they can simply exchange their attribute keys so that they are both able to decipher the ciphertext even if they separately do not own both attributes.  

Collusion resistance is ensured by issuing each user a secret key that is blinded by a random value. This random is different for each user and will vanish on decryption if and only if the attribute secrets satisfy the given access policy and are all originated from the same user. However, if two users collude they will mix their blinded values resulting in a plaintext that is still blinded by some unknown value. \cite{bethencourt2007ciphertext} In later schemes the unique user identifier (\ac{UID}) is used as the blinding value for private attribute key. \cite{li2017two} If used with the right attribute secret keys the user is able to use pairings to substitute his blinding value and recover the underlying secret. 

\subsection{Comparing Secure Group Communication To Attribute-Based Encryption}
\label{sec:comparing-secure-group-communication-to-attribute-based-encryption}
Comparing \ac{SGC} to \ac{ABE} is non trivial. This is due to a different encryption technique used by \ac{ABE} namely paring. Pairing scales more or less with the overhead of \ac{RSA} rather then \ac{ECC} or block ciphers as stated by \textit{Galbraith et. al.} \cite{galbraith2008pairings}. But to achieve the same bit security, computations in pairing need to happen in a much bigger bit-field and thous rendering \ac{ABE} less performant in comparison to \ac{RSA}. But in specific scenarios \ac{ABE} uses less keys to setup the group communication. In the following this scenarios will be described and analyzed to find out where this schemes differ and what use-cases \ac{ABE} schemes address.

In a \ac{RSA} sharing scheme, each user has his own public key which needs to be transmitted to a third party to establish a secret connection. Creating a group under this scheme will implicitly force the data owner to retrieve all $n$ public keys of all $n$ group members. The central server needs to provide a \ac{PKI} together with the public keys of each registered user to proof their identity. Thus follows the constrain that the central server needs to be available all the time to provide public keys for new registered users. Each member in the group receives an encrypted copy of the group key. The number of keys in \ac{SGC} scales at least linearly with the number of members. 

\ac{ABE} breaks the constrain that the central server has to be available at all time. This is done by using attribute keys on encryption rather then the users public keys. This reduces the number of keys that need to be maintained to the size of the attribute set describing the group. If an new user is registered in the system no new keys need to be downloaded from the view of the data owner. The registered users retrieves his attribute set and eventually can decrypt the shared files if his attributes satisfy the access policy of the group. Further notable is that the number of keys that are maintained in the group remains constant in $a$. With $a$ donating the number attributes used to describe the group. 

Given this observation it can be stated that \ac{ABE} is adventitious in scenarios where users address an unknown group of individuals. This can be some departments (e.g. attribute: police department of New York), colloquiums (e.g. attribute: chairman of TU-Berlin), or general user groups (attribute issued to all employees working in the security research team).

To better clarify the scalability advantage of \ac{ABE}, GKMP is compared to ABE \footnote{Specifically the ciphertext-policy ABE scheme of \cite{bethencourt2007ciphertext} is used in the comparison.} to evaluate the performance of both encryption schemes in general.

\begin{table*}[!ht]
\centering
\begin{tabular}{l 		| l 						| l 						| l }
 						& \textbf{Bdrive}			& \textbf{\ac{GKMP}} 			& \textbf{\ac{ABE}} 		\\
\hline
\textbf{initial share} 																				\\
keys 					& $O(nf)$ 					& $O(1)$	 				& $O(1)$			\\
messages (unicast)		& $O(nf)$  					& $O(n)$					& $O(n)$			\\
messages (multicast) 	& $O(nf)$ 					& $O(n)$ 					& $O(1)$			\\
encryptions				& $O(nf)$ 					& $O(f + n)$				& $O(a)$ 			\\
\hline
\textbf{member join} 																				\\
keys 					& $O(f)$   					& $O(1)$					& $O(1)$			\\
messages (unicast)		& $O(f)$  					& $O(1)$  					& $O(1)$ 			\\
messages (multicast) 	& $O(f)$ 	 				& $O(1)$					& $O(1)$ 			\\
encryptions				& $O(f)$  					& $O(1)$					& $O(1)$ 			\\
\hline
\textbf{member leave}																				\\
keys 					& $O(0)$					& $O(1)$					& $O(1)$			\\
messages (unicast)		& $O(0)$					& $O(n)$  					& $O(N(a^{-1}))$	\\
messages (multicast)	& $O(0)$					& $O(n)$					& $O(1)$ 			\\ 
encryptions 			& $O(0)$					& $O(f + n)$ 				& $O(F(a^{-1}))$	\\
\hline	
\textbf{addition of filekey}																		\\
keys 					& $O(n)$	 				& $O(0)$					& $O(0)$			\\
messages (unicast)		& $O(n)$	 				& $O(0)$					& $O(0)$			\\
messages (multicast)	& $O(n)$ 					& $O(0)$ 					& $O(0)$			\\
encryptions				& $O(n)$ 					& $O(1)$					& $O(1)$			\\
\hline
\end{tabular}
\caption{Comparison of Bdrive, \ac{GKMP} and \ac{ABE} scheme. $n$ donating the number of members, $N$ the number of all users in the system, $f$ the number of file keys in the group, $F$ the number of all filekeys, $a$ the number of attributes used for this group, $A$ all attributes }
\label{tab:comparisonsOWFTtoABE}
\end{table*}

Here the distribution of $a < n < f$ (number of attributes in the system is smaller than the number of devices which is smaller than the number of file keys) for a growing number of users is assumed. While this assumption does not necessarily hold true, on average this constrain will be satisfied. Under this assumption we can extract from table \ref{tab:comparisonsOWFTtoABE}, that \ac{ABE} indeed scales better then \ac{OWFT} and Bdrive on initialization and member join. ABEs disadvantage is located in the member leave operations. Most likely the member leave would describe a degradation or revocation of an attribute. \ac{ABE} suffers from additional overhead due to updating the attribute key for each user owning this old attribute ($N(a^{-1}$) and additionally updating all cipher text that were encrypted with the revoked attribute ($F(a^{-1}$).

On the meta level, attribute-based encryption tackles the rekeying problem by focusing on attribute and groups rather then individuals. \ac{ABE} reduces the number of keys needed by reusing and combining existing keys. In contrast stands secure group communication schemes which need to create a new key per each group. Here \ac{ABE} exploits the fact that groups generally can be described by an unique attribute set. Implicitly it follows that if another group is described by the exact same set of attributes the same keys are used. So the total number of groups is limited to all possible combinations of attributes. 

%Lets define an scenario adventagous to \ac{ABE}. Alice wants to share a file with all management members of the coffee company. Since she does not know the members in person, nor their email addresses, she simply creates a share with the group "management of coffee company". Alice only needs to retrieve the key of the management from the central server of the coffee company. This proceedure took Alice, one encryption and two tranmissions: one to retrieve the key and one to upload the encrypted text. 

%If we apply the same scenario to \ac{SGC} we face a problem. How to know which public keys belong to the executive officers? Alice need to check on the webside which people are in charge of the coffee company, to download thier public keys, encrypt the group key with their public keys, and upload the file and the \ac{GK} for each manager. This took alice one lookup of the role to key mappings, $n$ downloads of public keys, $n$ encryptions of the \ac{GK} for each member and one encryption of plain text, and two uploads of the cipher text and the group key.         

In conclusion is \ac{ABE} more suitable to make the rekeying process of Bdrive more scalable. Some could clearly see that \ac{ABE} scales with the number of attributes which is assumed to be less than the number of clients. Further, \ac{ABE} does not only handle the encryption but also provides an authentication service. Users are bound to roles and attributes which are tightly interleaved with the encryption scheme. Bdrive target audience are business which by nature have some kind of attribute authority in the form of role management and authorization mechanism embedded. Here \ac{ABE} can enfold its true potential and outperform SGC schemes not only in efficiency but also in additional security features. 