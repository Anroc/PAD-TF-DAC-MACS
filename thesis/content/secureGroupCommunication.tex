\section{Bdrives group communication scheme}
\todo[inline]{find better title}

In Bdrive each device of a user generates a new RSA key pair on registaion. The fingerprint (hash) of the public key identifies the device uniquly. To save a file in the cloud the device fist encrypes the file symmetrically with the so called "filekey". The filekey equals the hash of the plain file content and so ensures tamperproofness and integirty on decryption. Since Bdrives supports end-to-end encryption the server should never be able to decrypt the file by itself. So the device encrypts the filekey asymmetrically with its own public key and uploads the filekey to the Bdrive server were it is stored securly. The encrypted file is uploaded to the different cloud storage provider. 

If the user wants to access a file locally, the devices requests the encrypted filekey from the server, downloads the file chunks from the cloud storage providers, decrypts the file key with his privat key and finally decrypts the file with the filekey. 

So far we saw how the encryption process is handled for a single device. However, this process turns out to be much more complex in computation in a multible devices setting.  If a user registers more then one device the exisiting data needs to be syncronized to the new device. The server nodifies the existing device for the new registered device and the public key of the new device is downloaded. Now, each filekey for each file of the user needs to be downloaded from the server and decrypted. To make them accessable for the new devices, they are encrypted with the new devices public key and uploaded again to the server. The new device can now start to download and decrypt the filekeys as decibed previously. 

Some may notice, that this approach is not scalable for a large number of devices. Others may argue that a user never has so many devices that this process is no longer maintanable. But a cloud storage system provides the possibility to share the files with other users. Which means that each device of the user that accepts the invitation to the share needs to have an own encrypted file key. This process scales with $O(n * f)$ keys. Were $n$ donates the number of devices onvolved in the sharing and $f$ the number of file versions in the share.\footnote{Each file consit of many file versions. Each file version needs an own file key since the content changes each time the file is updated.} Futher, we need to send $O(n * f)$ messages to send each device its personal filekey and we need to encrypt each filekey $n$ times which also results in $O(n * f)$ encryptions in total. 

If a new devices joins the share we need to make the existing file keys avaiable to the new devices which results in $O(f)$ additional encryptions, messages and keys. However, a big adventage of this scheme is that we don't have to anything if a member leaves the group. We simply remove all the filekeys belonging to the left device and do not further encrypt new uploaded files for this device. Forward secrey\footnote{Forward Secrecy: The left member do not have any knowledge about future shared content.} is ensured. Backwards secrecy is also provided since a device needs to rekey for the newly joined member to make the files accessable for him. 

How can we do better then this while still maintaining the same level of security? 


\section{Secure Group Communication}
The most simple approach to this challange is to create a secret \textit{group key} (GK) each time multible devices need to access the same file. This schemes are called "Secure Group Communication". The main idea is to reduce the number of filekeys by encrypting all the files with a unique GK that is only known to the members in the share. Very simple approaches use a so called "Key Distribution Center" KDC to distribute the group keys to each member. However, while Bdrive could manage backward and forward secrecy quite easily, this schemes suffer from additional rekeying overhead if the number of members change. 

Often Secure Group Communications are mentioned together with \textit{multicat messages}. The idea is that on \textit{unicast} a central authority is required that manages authentication and authorization to decide which entity should access which content. With multicast messsages content is distributed to each entity regardless if this entity is authorized to view the content. Authorization is handled via encryption of the content. If an entity owns the key to decrypt the data it is implizity authorized to view the content. Multicast messages are expecially handy in group communciations since we only need to send one message to distribute the information to all members.\todo[inline]{sources??, verify if this is true} 

\subsection{Group Key Management Protocol}
The Group Key Management Protocol (GKMP)\cite{harney1997group} addresses this issue in a simple but more scalable way. If a device want to share files with a group it creates the group key and encrypts all filekeys with this group key. This GK needs to be securly distributed to all members which means that the data owner needs to download and store every public key of the group members and encrypt the GK for each of them. Further, the data owner needs to encrypt all shared filekeys symmetrically with the chosen group key. 

To ensure backward and forward secrecy, the GK needs to be renewed everytime the set of group members change. This process is located in the same computational magintude as bootstrapping a new group. However, on member addition we can exploit the fact that the existing GK is known to all members already. This helps on reducing the number of encryptions, since we can encrypt the new GK with the old GK which saves us $n-1$ encryptions.  

The big adventage of this scheme, compared to the scheme employed in Bdrive, is that it recudes the overhead of encryptions, messages and keys on new file uploads dramastically. While the data owner had to create a filekey for each member respectivly, GKMP reduces this to one filekey per upload.  

\subsection{Logical Key Hirachy}
\begin{figure*}[!ht]
\centering
    \includegraphics[width=0.8\linewidth]{img/LKH.png}
    \caption{Balanced binary LKH and \textbf{User H} joins or leaves the group. Node marked in yellow is newly added to the group. Node marked in green require an update.}
    \label{fig:lkh}
\end{figure*}
\todo[inline]{fix image placement}

Logical Key Hirachy (LKH)\cite{wallner1999key} is a GKMP that reduces user side storage and rekey-tranmissions by organizing users keys in a tree hirachy and maximaly exploiting the use of multicast messaging. The whole tree is mainted by the KDC. In the litrature it is explicitly stated that this trees neither habe to be balanced nor binary, but for the sake of simplity excatly this is assumed. Users (and their respecitv public keys) are organized on the lealf if this tree. Each node is composed of a key that is encrypted respectivly with its children keys. This encrypted key is known to all leafts related to this node and can, on change of this node, be transmitted in one multicast transmission to all its leafs. The root node summarizes the GK. The GK is used in the same way as in GKMP to secure the group communication. 

While in GKMP each user needs to store each members public key to eventually rekey the group, in LKH each user only needs to store $log(n) +1$ keys (path from leaf to root node). Beginning from the buttom each leaf node could decrypt the next parent node until it arrive at the root node. The other adventage is that many members share the same keys. So it is more efficient to transmit this keys in a multicast setting.  

In figure \ref{fig:lkh} user H recently joined the group which means, that to ensure backward secrecy, the keys in node GH, EG and GK must be updated. The key server will choose a new GH', EG' and GK' and encrypts and distributes them in a buttom up fashion starting by GH'. GH' is encrypted with user Gs and user Hs public key (G-PK, H-PK) and send to them. Next, user E and F receive in a multicast transmission EG', which is encrypted with EF and user G and H receive in a multicast transmission EG' which is now encrypted with the newly established GH' key. Finally, GK needs to be updated. GK' is encrypted with AC to multicast transmit it to the users A, B, C and D. And GK' is encrypted with EG' to transmit it in one message to user E, F, G and H. In a similar way the keys would be updated if User H would be removed from the group to ensure forward secrecy.   


\subsection{One-way function trees}  

