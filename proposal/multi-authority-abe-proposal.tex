%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twocolumn]{article}

\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics


\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{Multi-Authority ABE for Bdrive$\bullet$ July 2018 $\bullet$ Vol. I, No. 1} % Custom header text
\fancyfoot[EL]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[textsize=footnotesize]{todonotes} % for todo notes

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Multi-Authority Attribute Base Encyrption Scheme for Bdrive } % Article title
\author{%
\textsc{Marvin Petzolt}\\[1ex] % Your name
\normalsize TU Berlin \\ % Your institution
\normalsize \href{mailto:marvin.petzolt@protonmail.com}{marvin.petzolt@protonmail.com} % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
If a group of user want to share a ciphertext, they need to agree on a shared key. On each user leave and join this shared key needs to be updated for each user to ensure forward secrecy. Classical encryption reaches the point where this approach is no longer feasible for a large number of users. In this work the young field of attribute based encryption will be analysed to solve this issue for a secure could storage environment (BDrive). Different ABE and MA-ABE schemes will be compared and analyed for their applayablity in BDrive. In the end a practical implementation of a MA-ABE scheme will be given and evaluted for the pracical usage.
\todo[inline]{this abstract sucks: improve abstract}
\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\twocolumn[
    \maketitle
]


%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
\label{sec:introduction}

\lettrine[nindent=0em,lines=3]{B}
drive is a secure cloud storage where files get split up in smaller chunks that are saved separately on different storage provider. To ensure end-to-end encryption a Bdrive client encrypts each of his chunks with the a one-time symmetric key that is then encrypted under his own public key. This encrypted key is called a file key and it is uploaded to the Bdrive server where it is stored securely. 

Since each device of the same user has a different private-public key pair, the client is in charge of making the file keys available for the new client. This is done by downloading each file key for the receptive file, receiving the public key of the new client, decrypting the file key with his own private key, encrypting it again with the public key of the new device and finally, uploading the new file key to the Bdrive server.

The number of file keys that need to be maintained raises linearly with the number of clients. In addition Bdrive allows to share files between different users. For each device of each user involved in the sharing a new file key has to be created and maintained. We reach the point where the classical public-key end-to-end encryption scheme does not scale anymore. We would like to have an encryption scheme which has a contant number of file keys regardless of the number of clients.

%The formula \ref{eq:rekey} describes the number of file keys Bdrive that need to be stored for each shared files between $U$ users, where each user $u_{i \in U}$ has $u_d$ devices.

%\begin{equation}
%n = \sum_{i}{d_i}
%\label{eq:rekey} 
%\end{equation}

%Lets construct an example where the manager of a company wants to create a shared folder with all company employees. It is a medium sized company with $50$ employees. Lets assume that at least haft of them have two Bdrive clients running. The manager wants to upload the $250$ photos of the last company trip.
%We end up by computing $3/2 * 50 * 250 = 18750$ file keys and for every new file uploaded $75$ new file keys need to be uploaded. 



\section{Related Work}

Attribute Based Encryption (ABE), first introduced by Sahai and Waters \cite{sahai2005fuzzy}, is a cryptographic encryption scheme which encrypts under attributed that describe a user, rather than common known keys. This enables the encryptor to craft a cypher text over chosen attributes that can only be decrypted by any entity that holds a super set of matching attributes. Further, it is possible to embed an complex access structure (e.g. an access tree) inside the cipher text, where each node contains "AND" or "OR" gates. If the attribute values are stored in the leafs, the decryptor can iterate the tree in a post-order fashion and evaluate whether the root node yields "true" or "false". This approach was first introduced by Bethencort, Sahai and Waters and was called Ciphertext-policy Attribute-Based Encryption (CP-ABE). \cite{bethencourt2007ciphertext}. 
It is also possible to do it the other way around: Associate the user's key with an access policy. Now, the encryptor needs only to encrypt a given plain text with the public key of specific attributes so that only users who hold the right keys are able to decrypt the cipher text. This approach is called Key-Policy Attribute Based Encryption (KP-ABE).\cite{goyal2006attribute} 

This approaches are limited to one attribute authority. So only one trusted entity is in charge of issuing attributes and their matching key pairs. However, in the real world we would like to distribute the issuing of attributes via different domains. A new scheme is needed where different attribute authorities cooperate to handle communications between users of the same domain as well as cross domain communications.  

% The basic idea is, as proposed in \cite{chase2007multi}, to construct for each users a polynomial of degree $d-1$, where $d$ donates the number of attributes in our system. 

Multi-Authority Attribute Based Encryption (MA-ABE), first proposed by chase 2007 \cite{chase2007multi}, allows to multibe attribute authorities to maintain different domains. To ensure collusion restiance between users of different domains, a central trusted authoritiy (CA) was introduced to assign each user a unique identifier (UID). The big disadventage in this scheme was, that the CA had global decryption power and so has to remain trusted. 
%To prevent collusion between user in a multi authority setting, the challenge for each user needs to be individual. But it still needs to be ensured that the encryption of a message is independent of any user specific identifier, since the encryption progress should sourly depend on the attribute set known to the system.
%To mitigate this problem a global identifier (GID or UID) per users was introduced that is shown to each attribute authority (AA) to receive the corresponding private key for the users attributes. 
%The central authority (CA) now has to make sure that the user dependent challenge results in a global decryption key to decrypt the message.
%In fact the CA has to be trusted since it computes the users private keys in such a way that on decryption it reveals the global decryption key. 
Chase addressed this issue in \cite{chase2009improving} by distributing the master secret key generation over the AAs. However, since the global master secret is computed on system inizialiation, no more AAs can be added afterwards without rebooting the system. Also the scheme did not support attribute revocation which renders it not practical applicable. 
% Each authority uses this seed in combination with a pseudo random function to deterministically create the users private key. Since the CA possesses the same seed, same pseudo random function and issues the users GID, it can also compute the same private key as issued by the corresponding AA. So it can ensure that on decryption the keys add up to reveal the global decryption key. This scheme has a major issue: The CA has global decryption power. 

% Chase notices this problem as well and tried to mitigate it by decentrializing the seed generation \cite{chase2009improving}.  First user attributes could not easly be revoked\footnote{Chase proposed to assign each user a range of GIDs, so that a user can migrate to the next GID on revocation. Since the GID range is finite, this solution does not scale.}. Second AA's cant be added on runtime without reissuing each user his keys. And last, the attribute universe is finite (no large-universe). Further we noticed that if a failure of one AA renders the system unresponsible, since a cyphertext includes attributes from each authority. 

Access control for multiauthority cloud storage (DAC-MACS) \cite{yang2013dac} introduced a scheme that tackels both of this issues. Here a CP-ABE scheme was used to model the access control to the cyphertext. Furhter, each authority recieves its own ciphertext that depndens only on the attribute keys issed by this domain. While chase managed to maintain "one-plaintext-one-ciphertext", DAC-MACS needs to created $k$ ciphertext: One per attribute authority.\footnote{If the ciphertext does not require any attribute of an specific authority it does not have to create a ciphertext for this domain.} DAC-MACS does not require any additional coordination between the authorities which enables to add new authorities at runtime without recreating the user keys. This scheme also includes features for efficient revocation while it claimed to maintain forward and backward secrecy. As it turned out DAC-MACS was not collusion resistance under the active attack model on attribute revocation as shown by \cite{wu2017security}. A new scheme called NEDAC-MACS (New Extended DAC-MACS) was introduced that showed and solved the vulnerability. Recent studies introduced a more efficient, scalabe and secure approach such as MAACS \cite{li2016secure} and TFDAC-MACS (Two-Factory DAC-MACS)\cite{li2017two}. The DAC-MACS family is furhter know for the proxy decryption technique, first introduced by \cite{li2013matrix}, where a honest-but-curiuos server helps the user for decryption.

Also honorable is the work of Priscilla and Nagarajan 2018 \cite{nagarajan2018overview}, who conducted an overview and reseach anaylis of the DAC-MACS family for secure could storage systems. The reseach in this work will in addition focus on alternative approaches to ABE to improve scalability of secure cloud storage systems and compare the field of ABE and MA-ABE more deeply.    

%------------------------------------------------

\section{Security Requirements}
\label{sec:securityRequirements}
The core security requirements regarding Bdrive in the context of a multi-authority ABE scheme are the following:
\begin{itemize}
\item \textbf{Collusion resistance:} For two users it should not be possible to combine their attributes to archive a higher level of decryption power.
\item \textbf{Inter-Company Sharing:} Since Bdrive would need to consider a multi-authority ABE scheme, it should not be possible for a company to decrypt or issue files of other companies if no explicit exception is given for certain files by a trusted company relationship. A companies attribute authority (AA) should be responsible for its domain. In the case of an inter company relationship, attributes needs to be issued across different companies. 
\item \textbf{Central Authority:} In a multi-authority setting usually a central authority is coordinating the different attribute authorities to identify users and prevent collusion. However, it should not be possible that the central authority has a global decryption power.  
\item \textbf{Secret Master key (if any):} Key recovery requires a secret and securely stored master key. It should solely function in the company domain and not globally. 
\item \textbf{Large Key Universe:} The key universe should be large so that Bdrive can act dynamically regarding attribution issuing and each company could define their own set of attributes. Further, a finite field of keys would restrict the number of possible users in the system, which is not intended.
\item \textbf{Adding new Attribute Authorities:} It should be possible to add new attribute authorities at runtime. Without either shutting down the system or recreating each key.
\item \textbf{Key and Attribute revocation:} Either a period defining the lifetime of valid keys or a direct revocation mechanism ensures key and attribute revocation. In both cases the keys have a limited lifetime of two months. After this period the keys become invalid and have to be reissued.
Key attribute or whole key revocation should be possible to handle user management in terms of attribute promotion, attribute demotion and key revocation. Revoked keys are no longer able to decrypt the cypher text. 
\end{itemize}

Other (optional) requirements are: 
\begin{itemize}
	\item \textbf{Traidor tracing:} Since users only identifiable by their attribute set, BDrive needs a technique to somehow identify misbehaving users. This could lead to the fact that a malicious user provide a decryption black box for sale.\cite{liu2016practical} This can further be used for auditing and more fine granted access control mechanism.
	\item \textbf{Fine-granted access control:} Some schemes restrict the user to threshhold access policies, where an user needs at least $n$ of $m$ attributes to encrypt the cipher text. \cite{chase2007multi} \cite{chase2009improving} Other approaches are restriced to $AND$ gates which would translate to $m$ of $m$ threshhold gates. \cite{li2017two} The user shell not be bounded on defining access policies which requires either an access tree \cite{bethencourt2007ciphertext} \cite{yang2013dac} \cite{wu2017security} \cite{li2013matrix} or an linear secret sharing scheme (LSSS) \cite{liu2016practical}.\todo[inline]{shorten?}
\end{itemize}

\section{Targets}
The target of this work split into two requirements: the theoretical part and the practical implementation. In the theoretical part (minimal requirement), papers and topics are analyzed if they fit BDrives security requirements. It will be evaluted, whether Attribute-Based Encryption is the best solution to the scalability problem of BDrive and ABE will be compared to other alternative candidates. More deeply will the topic of ABE be analysed. Here is the goal to find or construct the best maching scheme for BDrive. This approaches will be evaluted with respect of scalability, performance and security. The security requirements of section \ref{sec:securityRequirements} need to be satisfied by the selected or contructed approach.

For the pratical part several options exist. Depending on the result of the theoretical work, either the contructed or selected scheme should be implemented in a propotype in a BDrive related environment. If an practial and usable implementation for this scheme already exists, it should be included more deeply in BDrive. That means that a propotype should be implemented that is capable of spliting files, generating file keys and sharing this file key across different companies. The performance and scalability of this system should be evaluted against the current employed BDrive scheme. If this is also already done, it will be evaluated how usefull MA-ABE is in a real world setting. Recent paper anayzed practical ABE in medical domain. \cite{thatmann2016please} \cite{li2013scalable} \cite{akinyele2011securing} However, a differnt setting exist in the secure cloud storage domain. It should be evaluted where to extract the attributes from to solve the bootstrapping problem and how end users benefit from the new security scheme.

%------------------------------------------------
 
\section{Concept}
To extract the best security scheme for BDrive several points need to satisfied: Performance, Scalability, Security and fitting the Security-Requirements. To do so the theoretical part will be split into different sections.\\

\subsection{Theoretical part}
	\textbf{Evaluation of the alternative security schemes.} \textit{(2 weeks)} \\
		  First it needs to be clarified, if ABE is the right tool to contermeasure the scalability problem of BDrive. Hence, different related security schemes shall be evaluated and compare to each other. This techniques can be for example speeding up the encryption throuput by using EC encryption instead of RSA. The scalability issue for large group communication is not new. Several approaches exist to make the re-keying process for group members more efficient. This schemes are called secure group communications and will be used to create a more efficient rekeying scheme.\cite{wong2000secure}

	\textbf{Evaluation of Attribute Based Encryption schemes.} \textit{(5 weeks)} \\
		  To compare different ABE approaches, a homogeneuos platform needs to be created. With this platform the different approaches can be implemented and compared regarding scalability (number of users, number of attributes, number of resulting cipher texts, number of keys that need to be stored). To reduce the number of possible candidates, the ABE paper will be clustered into topics and a representing candidate will be choosen. If an reference implementation is given this implementation will be translated into the homogenous environment. Other wise an implementation will be written. 
		  The target of this section will be to construct a comparable metric of different ABE approaches and to construct an overview table containing different features and the matching requirements. 

	\textbf{Evaluation of MA-ABE schmes.} \textit{(5 weeks)} \\  
		  If the result of the previous section would be that MA-ABE schemes fit best, the next step would be to construct an deeply analysis of the different MA-ABE schemes. This will happen in the same way as in the previous section: First different schemes will be clusted into topics. Candidates from this topic will be chosen and compared against each other. Here can also the number of attribute authorities be varied to evalaute the scalability of the respectiv scheme. 
		  In the conclusion should be a either a well argumented approach extracted from an paper or an self designed scheme if the related work leaks some requirements.    

\subsection{Practical part} 
	\textbf{Implementation of selected scheme} \textit{(4 weeks)}\\
		  The extracted scheme of the theoretical part will be implemented. If an reference implementation is given this implementation will be used. If no implementation is given the goal is to create a prototype cryptographic library. To contruct a comparable scheme like BDrive a prototype file sharing system needs to be implemented that acts in the same way as BDrive does. 
		  If an working implemenation is already given a user study will be done to evaluate whether user even benefit from the new security scheme. Here MA-ABE will be evaluted regarding usability, performance, real-world scalability. The central question would be if real-world use-cases exist where ABE can clearly out-perform classical public-key encryption.

	\textbf{Evaluation of implementation} \textit{(2 weeks)}\\
		  As introduced in section \ref{sec:introduction} the main target is to make BDrive more scalable. This will be done by evaluating a new crytographic scheme that reduces the number of file keys that need to be maintained per file. With MA-ABE we expect to reduce the number of file keys per file to at least $n = k$. Where $k$ is the number of attribute authorities and assuming that we don't have revoced attributes yet. 
		  Since computing pairing requires a bigger overhead then computing the power of a prime as in RSA, we need to compare the time it takes to encryt the file key. To show that MB-ABE is indeed faster we would compare this time for an increasing number of devices. While we expect to DAC-MACS's comuting time to remain constant on encrypting for a increasing number of devices, we expect a linear increasing function for RSA. 
		  
	\textbf{Summarzing results and concluding thesis.} \textit{(6 weeks)}\footnote{Master thesis are restircted to 26 weeks in total. The remaining two weeks are reserved for unexpected difficulties or delays.}\\
		  The remaining time will be used to write the thesis and collect the results.   

% --------------------------- DAC-MACS -------------------------

%For the design of the BDrive MA-ABE scheme the paper \cite{yang2013dac} will be used. Here the encryptor encrypts for each attribute authority the ciphertext with the required attributes, so that he endups with $k$ cyphertext, one for each authority. So DAC-MACS breaks the "one-plaintext-one-ciphertext" contains, but makes the AAs independent from each other. This is the mayjor difference between DAC-MACS (\cite{yang2013dac}) and chases multi-authority proposals (\cite{chase2007multi}, \cite{chase2009improving}). DAC-MACS comes also with a handfull of security features that are requirements of BDrive as proposed in section \ref{sec:securityRequirements}. The scheme consist of three entities:

%\begin{itemize}
%\item \textbf{Certificate Authority (CA)}: Issues users global identifier (UID) to make the user distinglishable and prevent collusion. It signs the users arttibutes such as the Public key, UID and other user specific security paramter. 
%\item \textbf{Server}: The server helps the user by decryption the cyphertext and re-encryption his cyphertexts on attribute revocation. The server does not have global knowledge over the ciphertext, since it decrypts first to a decryption token, that can only be decyrpted by the users privat key. 
%\item \textbf{Attribute authority (AA)}: Each AA is responsible for their own domain attributes. They generate independenlty thier own secret and public key components and issue the user his attributes. Each attribute key is verioned, so that for revocation the AA simply needs to increase the version number and reissue the user his keys. The user hisself need then to update the cyphertexts. 
%\end{itemize}

%DAC-MACS fits the security requirements of BDrive quite well. In the following each requirement will be analysed and dicussed how DAC-MACS solves this problem. 

%\begin{itemize}
%\item \textbf{Collusion resistance:} This is the key requirement of each ABE scheme. In a Multi-Authority setting we need to additional ensure collusion resistance between users of different authorities. In DAC-MACS this is done in the classical way as also in other Multi-Authroity schemes: By using global unique user identifier. They are presented to each authority in exchange of the users secret attribute keys. This secret keys contain the user public key component so that on decryption the attribute specific ciphertext first resolves into the another ciphertext that can only be decyrpted with the users privat key. As argumented collusion resistance is ensured in that way that if users would combine their secret keys of an attribute key are not able to archive a higher level of decyrption power since the attribute specific ciphertext will resolved in an undecryptable cipher text.  
%\item \textbf{Inter-Company Sharing:} This requirements is given by nature of an multi-authority scheme. A user needs to obtain attributes from both, the own and the foreign authoritiy to encrypt ciphertext in thier domain.
%\item \textbf{Central Authority:} The certificate authority and the server are both serving as cental authorities. While the Server is only semi-tursted (honst-but-currious), the certificate authrotity need to be trusted since the global user id needs to be unique over multibe users. If this contains is not preserved collusion would be possible. The CA does also not have global decryption power since the user specific attribute keys dependt on the users public key, that is chosen by the user secretly. 
%\item \textbf{Secret Master key (if any):} Since each ciphertexts are encrypted under the public key of the attribute authority and do not depent on any specific user security paramters, the attribute authority can decrypt the ciphertext. However, it can not decrypt the cyphertext of other attribute authorities.  
%\item \textbf{Large Key Universe:} De- and encryption scales linearly with the number of attributes and authorities. Revoking attributes only affects the cipher text and keys that are associated with the revoked attributes. 
%\item \textbf{Adding new Attribute Authorities:} Since each attribute authoritiy issues it own independent keys, we can add new attribute authorities without re-encyprtion all cipher texts. 
%\item \textbf{Key and Attribute revocation:} Attribute keys are versioned to ensure forward-secrecy. Revocation also happens in a direct manner. Backward-security is ensured so that new keys can not decyrpt old cipher texts.  
%\end{itemize}

%The main scope is to reduce the number of rekeys that are used on scaling number of user and devices that access this file key. As mentioned before chase proposed a scheme that only needs to maintain one ciphertext per plaintext. But to act dynamically regarding Attribute Authorities additions, reduce the number of affected ciphertext re-encryptions, and provide an encryption process that does not need to involve all AAs known to the system, we need to split up the ciphertext per AA domain. Furhter, in chase scheme, we would also encounter the problem of DoS attacks where an AA can simply deny requrest and render the whole system unusable.  

%\todo[inline]{Explain how to evaluate and compare the ABE paper}



% --------------------------- MA-ABE chase -------------------------
%\begin{figure*}[!h]
%\begin{itemize}
	%\item \textbf{System}:\\
	%\textbf{Init}: Fix prime order groups $G$, $G$, bilinear map $e: G \rightarrow G$, and generator $g \in G$. Choose seeds $s_1, \dots, s_K$ for all %authorities. Also choose $y_0 , \{t_{k,i}\}_{k=1...K,i=1\dots n} \leftarrow Z_q$. \\
	%\textbf{System Public Key}: $Y_0 = e(g, g)^{y_0}$
	%\item \textbf{Attribute Authority} $k$: \\
	%\textbf{Auhtority Secret Key}: $s_k, t_{k, 1} \dots t_{k,n} $ \\
	%\textbf{Authority Public Key}: $ T_{k, 1} \dots T_{k, n}$ where $T_{k, i} = g^{t_{k,i}} $\\
	%\textbf{Secret Key for User } $u$: Let $y_{k,u} = F_{s_k}(GID)$. Choose random $d - 1$ degree polynomial $p$ with $p(0) = y_{k,u}$. Secret Key: $\{D_{k%,i} = g^{p(i)/t_{k,i}} \}i \in A_u $.
	%\item \textbf{Central Authority}:\\
	%\textbf{Central Authority Secret Key}: $s_k$ for all authorities $k, y_0$.  \\
	%\textbf{Secret Key for User} $u$: Let $y_{k,u} = F_{s_k}(GID)$ for all $k$. Secret Key: $D_{CA} = g^{y_0 - \sum^K_{k=0} y_{k,u}}$
	%\item \textbf{Encryption for attributes set } $A_C$: \\
	%Choose random $s \leftarrow Z_q$. $E = Y_0^s m$, $E_{CA} = g^s$, $\{E_{k,i} = T^s_{k,i}\}_{i \in A^k_C, \forall k}$
	%\item \textbf{Decryption}:\\
	%For each authority $k$, for $d$ attributes $i \in A^k_C \cap A_u$, compute $e(E_{k,i}, D_{k,i}) = e(g,g)^{p(i)s} = e(g,g)^{y_{k,u}s}$.  Interpolate to find $Y^s_{k,u} = e(g, g)^{p(0)s} = e(g,g)^{y_{k,u}s}$ for each authority $k$. Compute $Y^s_{CA} = e(E_{CA} , D_{CA})$. Combine these values to obtain %$Y^s_{CA} * \prod^K_{k=1} Y^s_{k,u} = Y^s_0$. Then $m = E/Y_0^s$
%\end{itemize}
%\caption{Multi-Authority scheme as proposed by Chase 2007 in \cite{chase2007multi}. $A_u$ donates the attributes of user $u$. $A_C$ donates the attributes of the cipher text.}
%\label{fig:chase-multi-auth}
%\end{figure*}

%\begin{figure*}[!h]
%\begin{itemize}
	%\item \textbf{System}:\\
	%\textbf{Init}: Fix prime order groups $G$, $G$, bilinear map $e: G \rightarrow G$, and generator $g \in G$.

	%\item \textbf{Attribute Authority} $k$: \\
	%\textbf{Auhtority Secret Key}: $y_k \leftarrow Z_q$ (only used once), $s_{kj} = s_{jk}$ as exchanged with each authority $(k,j) \in (\{1 \dots N\} \%backslash \{k\}), t_{k, i} \leftarrow Z_q \forall i \in A_k$ \\
	%\textbf{Authority Public Key}: $Y_k = e(g,g)^{y_k}$, $ T_{k, 1} \dots T_{k, n}$ where $T_{k, i} = g^{t_{k,i}} $\\
	%\textbf{System Public Key}: Each authority computes $Y_0 = \prod Y_k = e(g, g)^{\sum y_k}$\\
	%\textbf{Secret Key for User } $u$: For $j \in \{1 \dots N\}\backslash \{k\}$: 
	%$Q_{kj} = g^{R_{kj}} * F_{s_{kj}}(GID)^{\delta_{kj}}$, $R_{kj} \leftarrow Z_q$ and set $\delta_{kj}$ to either $-1$ if $j<k$ otherwise $1$.

	%Choose random $d - 1$ degree polynomial $p$ with $p_k(0) = y_k - \sum_{j \in \{1 \dots N\} \backslash \{k\}} R_{kj}$. 

	%Secret Key: $\{D_{k,i} = g^{p(i)/t_{k,i}} \}i \in A_u $.

	%User computes: $Q_u = \prod_{(j,k) \in \{1 \dots N\} \times (\{1 \dots N\} \backslash \{k\})} Q_{kj} = g^{\sum_{(j,k) \in \{1 \dots N\} \times (\{1 \%dots N\} \backslash \{k\})} R_{kj}} = g^{R_u}$

	%\item \textbf{Central Authority}:\\
	%Issues unique $GID$ for user $u$.
	%\item \textbf{Encryption for attributes set } $A_C$: \\
	%Choose random $s \leftarrow Z_q$. $E = Y_0^s m$, $E_{1} = g^s$, $\{E_{k,i} = T^s_{k,i}\}_{i \in A^k_C, \forall k}$
	%\item \textbf{Decryption}:\\
	%For each authority $k$, for $d$ attributes $i \in A^k_C \cap A_u$, compute $e(E_{k,i}, D_{k,i}) = e(g,g)^{p(i)_{k}s}$.  Interpolate to find $P_k = e(g%, g)^{p(0)_{k}s} = e(g,g)^{s(y_k - \sum_{j \neq k} R_{kj})}$. Multiply $P_k$ together to get $V = e(g,g)^{s(\sum\{y_k\} -R_u)} = Y_0^s / e(g^{R_u}, g^{s})$. Compute $e(Q_u, E_1) * V = e(g^{R_u}, g^s) * V = Y_0^s$. Recover $m$ by $E/ Y_0^s$.
%\end{itemize}
%\caption{Multi-Authority scheme as proposed by Chase 2009 in \cite{chase2009improving}. $A_u$ donates the attributes of user $u$. $A_C$ donates the attributes of the cipher text.}
%\label{fig:chase-multi-auth-without-trusted-CA}
%\end{figure*}


%The basic idea is, as proposed in \cite{chase2007multi}, to construct for each users a polynomial of degree $d-1$, where $d$ donates the number of attributes in our system. 

%To prevent collusion between user in a multi authority setting, the challenge for each user needs to be individual. But we still need to ensure that the encryption of message is independent of any user specific identifier, since the encryption progress should sourly depend on the attribute set known to the system.
%To mitigate this problem a global identifier (GID) per users was introduced that is shown to each attribute authority (AA) to receive the corresponding private key for the users attributes. 
%The central authority (CA) now has to make sure that the user dependent challenge results in a global decryption key to decrypt the message.
%In fact the CA has to be trusted since it computes the users private keys in such a way that on decryption it reveals the global decryption key. 

%In \cite{chase2007multi} this is done by the CA generating random seeds that are distributed to the Attribute Authorities. Each authority uses this seed in combination with a pseudo random function to deterministically create the users private key. Since the CA possesses the same seed, same pseudo random function and issues the users GID, it can also compute the same private key as issued by the corresponding AA. So it can ensure that on decryption the keys add up to reveal the global decryption key.

%We set the multi-authority scheme proposed by Chase 2007 as a baseline for the building block of the concept. It is defined in figure \ref{fig:chase-multi-auth}. $g^{y_{k,u}s}$ is the user depending blinded point of interest (blinded by $s$), which is derivate from the pseudo random function $F(GID)$ with seed $s_k$. As already introduced, the seeds are choose by the CA in advance to ensure that the challenges for each authorities $k$ add up in $g^{y_0 - \sum^K_{k=0} y_{k,u}}$ to reveal the blinded master secret $g^{y_0 s}$, which is than used for decryption of the cipher text. This step is necessary to a) prevent collusion between users (so making the challenge for each user dependent) and b) to make the encryption independent of the user's GID. The authorities should not know the secrets (seeds) of the other AAs so that it can not issue attributes without of their domain. So the CA needs to be trusted and honest since it generates the master secret ($g^{y_0}$) and distributes the secret seeds ($s_k$). The CA has global decryption power.  

%However, as discussed in \ref{sec:securityRequirements} we want the company domain to remain sealed. That means that we don't want to have a global trusted authority that has global decryption power. 
%Chase addressed this issue in \cite{chase2009improving}, where she proposed the usage of an seeding network. Here every two AA's exchange seeds than combine them with the pseudo random functions to produce the users private key. 

%In the first step the master secret key $Y_0$ needs to be split apart the authorities. Each authority chooses independent a $y_k$ and sends $Y_k = e(g, g)^{y_k}$ to each other authority. Every authority than computes the global master public key $Y_0 = \prod Y_k = e(g, g)^{\sum y_k}$.

%For every user the authority $k$ computes a random polynomial $p_k$ with the point of interest defined as $p_k(0) = y_k - \sum_{j \in \{1 \dots N\} \backslash \{k\}} R_{kj}$.

%To build up our secret-seeding network, let $s_{kj}$ be the seed exchanged by authority $k$ with authority $j$ ($k \neq j$). For the user now to receive its decryption keys for authority $k$, he requests 
%$Q_{kj} = g^{R_{kj}} * F_{s_{kj}}(GID)^{\delta_{kj}}$ for each authority $j, j \neq k$. $R_{kj}$ is chosen randomly by the authority $k$. The clue is to set $\delta_{kj}$ to either $-1$ if $j<k$ otherwise $1$, so that later this values will cancel out each other. The user combines all collected $Q_{kj}$ decryption keys form each AA to compute his own unique, global decryption key $Q_u = \prod_{(j,k) \in \{1 \dots N\} \times (\{1 \dots N\} \backslash \{k\})} Q_{kj} = g^{\sum_{(j,k) \in \{1 \dots N\} \times (\{1 \dots N\} \backslash \{k\})} R_{kj}} = g^{R_u}$. Since all pseudo random functions are canceling out each other (depending on $\delta_{kj}$), the user receives his unique decryption key.  The full description of this scheme is described in \ref{fig:chase-multi-auth-without-trusted-CA}.

%We now successfully eliminated the trusted CA. However, several problems remain. How to add authorities? And how to change or revoke attributes?

%\todo[inline]{user and attribute revocation}

%-----------------------------------------------

\section{Conclusion}
With increasing number of users and devices, BDrive and any common cloud storage system faces scalability issues that are automatically given when using RSA cryptography. While using end-to-end encryption it is hard to hold different files in sync. This work should find or contruct the solution to this scalability problem. In the theoretical part the state of the art will be anaylzed and compared to find the best or closed scheme. In the practical part this scheme will be implemented and evaluated against the current implemented security scheme in BDrive. In the end it will be evaluated if ABE is practical appliable to solve the scalability problem.    

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\bibliography{multi-authority-abe-proposal} 
\bibliographystyle{ieeetr}

%----------------------------------------------------------------------------------------

\end{document}
